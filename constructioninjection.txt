Q1) How does the ConstructorInjection class demonstrate dependency injection, and what would be the impact of changing the implementation of the IText interface?
Steps:
Step 1) Open visual studio 2019 code -> create new project ->choose->Console App (.Net Core)

code:
using System;

namespace PropertyInjection
{
    public interface IText
    {
        void Print();
    }

    class Format : IText
    {
        public void Print()
        {
            Console.WriteLine("Hello World!");
        }
    }

    public class ConstructorInjection
    {
        private IText _text;

        public ConstructorInjection(IText text)
        {
            _text = text;
        }

        public void Print()
        {
            _text.Print();
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            ConstructorInjection cs = new ConstructorInjection(new Format());
            cs.Print();
            Console.ReadKey();
        }
    }
}



Q2) Explain how dependency injection is demonstrated in the provided code, particularly in the simple class's notify method.
code:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text;
using System.Threading.Tasks;
public interface INotificationAction
{
    void ActOnNotification(string message);
}

class simple
{
    INotificationAction task = null;

    public void notify(INotificationAction at, string messages)
    {
        this.task = at;
        task.ActOnNotification(messages);
    }
}

class EventLogWriter : INotificationAction
{
    public void ActOnNotification(string message)
    {
        Console.WriteLine("Click on the bell icon to get notifications.");
    }
}
class Program
{
    static void Main(String[] args)
    {
        EventLogWriter elw = new EventLogWriter();
        simple at = new simple();
        at.notify(elw, "to logg");
        Console.ReadKey();
    }
}

Output:






Q3) How does the client class utilize dependency injection through the run method, and what is the benefit of this approach?
code:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text;
using System.Threading.Tasks;
public interface Iset
{
    void print();
}

public class service : Iset
{
    public void print()
    {
        Console.WriteLine("print....");
    }
}
public class client
{
    private Iset _Iset;
    public void run(Iset serv)
    {
        this._Iset = serv;
        Console.WriteLine("start");
        this._Iset.print();
    }
}

class method
{
    public static void Main()
    {
        client cn = new client();
        cn.run(new service());
        Console.ReadKey();
    }
}

